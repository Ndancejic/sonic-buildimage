#!/usr/bin/env python3

"""
arp_update_checker

This script is intended to be run by Monit. It will write an alerting message into
syslog if it found arp_update script stuck on ping command.
Then it will attempt to restart arp_update script.

The following is an example in Monit configuration file to show how Monit will run
this script:

check program arp_update_checker with path "/usr/bin/arp_update_checker" every 10 cycles
    if status != 0 for 3 times within 3 cycles then alert repeat every 1 cycles
"""

import syslog
import subprocess
import sys

TIMEOUT=5.0

# Set up logging to syslog
syslog.openlog(ident='arp_update_checker', logoption=syslog.LOG_PID, facility=syslog.LOG_DAEMON)

def log_info(message):
    syslog.syslog(syslog.LOG_INFO, message)

def log_warning(message):
    syslog.syslog(syslog.LOG_WARNING, message)

def log_error(message):
    syslog.syslog(syslog.LOG_ERR, message)

def is_process_running(process_name):
    """Check if there is any running process that contains the given name."""
    try:
        # Use pgrep to check if the process is running
        output = subprocess.check_output(["pgrep", "-f", process_name])
        return bool(output.strip())
    except subprocess.CalledProcessError:
        return False

def is_arp_update_stuck(timeout=TIMEOUT):
    """Check if arp_update is stuck by looking for a ping command running longer than the specified timeout. (Default 1sec)"""
    try:
        arp_update_pid = subprocess.check_output(["pgrep", "-x", "arp_update"]).strip().decode('utf-8')
        child_pids = subprocess.check_output(["pgrep", "-P", arp_update_pid]).strip().decode('utf-8').split()
        for pid in child_pids:
            cmd = subprocess.check_output(["ps", "-p", pid, "-o", "comm="]).strip().decode('utf-8')

            if "ping" in cmd:
                start_time = subprocess.check_output(["ps", "-p", pid, "-o", "etime="]).strip().decode('utf-8')
                elapsed_time = parse_elapsed_time(start_time)

                # Check if the elapsed time is greater than the timeout
                if elapsed_time > timeout:
                    return True
        return False
    except subprocess.CalledProcessError:
        return False

def parse_elapsed_time(etime):
    """Convert elapsed time from ps command to seconds."""
    parts = etime.split('-')
    if len(parts) == 2:
        days = int(parts[0])
        time_part = parts[1]
    else:
        days = 0
        time_part = parts[0]

    time_parts = time_part.split(':')
    if len(time_parts) == 3:
        hours, minutes, seconds = map(float, time_parts)
    elif len(time_parts) == 2:
        hours = 0
        minutes, seconds = map(float, time_parts)
    else:
        hours = 0
        minutes = 0
        seconds = float(time_parts[0])

    total_seconds = days * 86400 + hours * 3600 + minutes * 60 + seconds
    return total_seconds

def restart_arp_update():
    """Restart the arp_update process."""
    try:
        subprocess.check_call(["docker", "exec", "swss", "supervisorctl", "restart", "arp_update"])
        log_info("arp_update process restarted successfully.")
    except subprocess.CalledProcessError as e:
        log_error(f"Failed to restart arp_update process: {e}")
        sys.exit(1)

def main():
    """
    This function will check if arp_update script is stuck and restart the script if needed.
    """
    if is_process_running("arp_update"):
        if is_arp_update_stuck():
            log_warning("arp_update process is stuck. Restarting...")
            restart_arp_update()
            sys.exit(2)
    else:
        log_warning("arp_update process is not running.")

if __name__ == "__main__":
    main()